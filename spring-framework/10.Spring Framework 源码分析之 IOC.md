Spring Framework 源码分析之 IOC
====================
# 1、从 HELLO IOC 看 Spring IOC 源码
本文以一个 hello ioc demo 的视角来解读 Spring IOC, 需要的童鞋可以 clone 我的分支进行 debug :

```text
https://gitee.com/abcart/Spring-Framework/tree/feature-learn-5.1.x/
```

## HELLO IOC 伪代码

- ``build.gradle`` 依赖

```
dependencies {
    compile(project(":spring-context"))
}
```

- 接口及其实现类
```
public interface IocService {
    String holloIoc();
}

public class IocServiceImpl implements IocService {

    @Override
    public String holloIoc() {
        return "HELLO IOC";
    }
}

```

- 配置文件 application-ioc.xml
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="iocService" class="org.springframework.app.service.impl.IocServiceImpl"/>

</beans>
```

- 执行入口
```
public class IocDemoApplication {

    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("classpath:application-ioc.xml");
        IocService iocService=context.getBean(IocServiceImpl.class);
        System.out.println("IocDemoApplication: "+iocService.holloIoc());
    }

}
```

从 IocDemoApplication 例子来看，打印 `HELLO IOC`，Spring 无非是做了如下几点工作：

- 读取配置文件 application-ioc.xml 
- 根据 bapplication-ioc.xml 中的配置找到对应的类的配置，并实例化
- 调用实例的方法

# 2、IOC 源码分析
 
### ClassPathXmlApplicationContext 的继承关系图：

![ClassPathXmlApplicationContext](images/10.ClassPathXmlApplicationContext-01.png)

### ClassPathXmlApplicationContext 源代码包含一个 Resource 数组和一堆构造方法，简述如下：
```java
public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext {

	// 配置文件容器
	@Nullable
	private Resource[] configResources;

    public ClassPathXmlApplicationContext(String configLocation) throws BeansException {
		// **
		this(new String[] {configLocation}, true, null);
	}

    	public ClassPathXmlApplicationContext(
			String[] configLocations, boolean refresh, @Nullable ApplicationContext parent)
			throws BeansException {
		// 根据父容器 new 一个 ClassPathXmlApplicationContext 对象
		super(parent);
		// 加载、解析 XML文件并将解析后的参数放在配置文件容器中 **
		setConfigLocations(configLocations);
		if (refresh) {
			// ***
			refresh();
		}
	}

}

```

## setConfigLocations() 解析

在加载、解析 XML 文件并将解析后的参数放在配置文件容器的过程中，setConfigLocations() 主要做了两件事情：

- 创建环境配置对象 ConfigurableEnvironment
- 处理 ClassPathXmlApplicationContext 传入的字符串中的占位符 

```java
public void setConfigLocations(@Nullable String... locations) {
    if (locations != null) {
        Assert.noNullElements(locations, "Config locations must not be null");
        this.configLocations = new String[locations.length];
        for (int i = 0; i < locations.length; i++) {
            // **
            this.configLocations[i] = resolvePath(locations[i]).trim();
        }
    }
    else {
        this.configLocations = null;
    }
}

protected String resolvePath(String path) {
    // setConfigLocations() 中做的两件事是在这完成的**
    return getEnvironment().resolveRequiredPlaceholders(path);
}

```

### 创建环境配置对象 ConfigurableEnvironment
```java
public ConfigurableEnvironment getEnvironment() {
    if (this.environment == null) {
        // **
        this.environment = createEnvironment();
    }
    return this.environment;
}

protected ConfigurableEnvironment createEnvironment() {
    return new StandardEnvironment();
}

public class StandardEnvironment extends AbstractEnvironment {

	/** System environment property source name: {@value}. */
	public static final String SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME = "systemEnvironment";

	/** JVM system properties property source name: {@value}. */
	public static final String SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME = "systemProperties";

	protected void customizePropertySources(MutablePropertySources propertySources) {
		propertySources.addLast(
				new PropertiesPropertySource(SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties()));
		propertySources.addLast(
				new SystemEnvironmentPropertySource(SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));
	}

}

```
StandardEnvironment 的继承关系图：

![StandardEnvironment](images/10.StandardEnvironment.png)

我们可以猜出 `getEnvironment().resolveRequiredPlaceholders(path)` 的处理逻辑是发生在这张继承关系图中，可以切换 methods 视图查看方法的依赖关系。

### 
```java
public String resolveRequiredPlaceholders(String text) throws IllegalArgumentException {
    // **
    return this.propertyResolver.resolveRequiredPlaceholders(text);
}

public String resolveRequiredPlaceholders(String text) throws IllegalArgumentException {
    if (this.strictHelper == null) {
        this.strictHelper = createPlaceholderHelper(false);
    }
    // **
    return doResolvePlaceholders(text, this.strictHelper);
}

private String doResolvePlaceholders(String text, PropertyPlaceholderHelper helper) {
    // **
    return helper.replacePlaceholders(text, this::getPropertyAsRawString);
}

public String replacePlaceholders(String value, PlaceholderResolver placeholderResolver) {
    Assert.notNull(value, "'value' must not be null");
    // ***
    return parseStringValue(value, placeholderResolver, null);
}

// 解析所有使用 ${} 方式的占位符
protected String parseStringValue(
        String value, PlaceholderResolver placeholderResolver, @Nullable Set<String> visitedPlaceholders) {

    int startIndex = value.indexOf(this.placeholderPrefix);
    if (startIndex == -1) {
        return value;
    }

    StringBuilder result = new StringBuilder(value);
    while (startIndex != -1) {
        int endIndex = findPlaceholderEndIndex(result, startIndex);
        if (endIndex != -1) {
            String placeholder = result.substring(startIndex + this.placeholderPrefix.length(), endIndex);
            String originalPlaceholder = placeholder;
            if (visitedPlaceholders == null) {
                visitedPlaceholders = new HashSet<>(4);
            }
            if (!visitedPlaceholders.add(originalPlaceholder)) {
                throw new IllegalArgumentException(
                        "Circular placeholder reference '" + originalPlaceholder + "' in property definitions");
            }
            // Recursive invocation, parsing placeholders contained in the placeholder key.
            placeholder = parseStringValue(placeholder, placeholderResolver, visitedPlaceholders);
            // Now obtain the value for the fully resolved key...
            String propVal = placeholderResolver.resolvePlaceholder(placeholder);
            if (propVal == null && this.valueSeparator != null) {
                int separatorIndex = placeholder.indexOf(this.valueSeparator);
                if (separatorIndex != -1) {
                    String actualPlaceholder = placeholder.substring(0, separatorIndex);
                    String defaultValue = placeholder.substring(separatorIndex + this.valueSeparator.length());
                    propVal = placeholderResolver.resolvePlaceholder(actualPlaceholder);
                    if (propVal == null) {
                        propVal = defaultValue;
                    }
                }
            }
            if (propVal != null) {
                // Recursive invocation, parsing placeholders contained in the
                // previously resolved placeholder value.
                propVal = parseStringValue(propVal, placeholderResolver, visitedPlaceholders);
                result.replace(startIndex, endIndex + this.placeholderSuffix.length(), propVal);
                if (logger.isTraceEnabled()) {
                    logger.trace("Resolved placeholder '" + placeholder + "'");
                }
                startIndex = result.indexOf(this.placeholderPrefix, startIndex + propVal.length());
            }
            else if (this.ignoreUnresolvablePlaceholders) {
                // Proceed with unprocessed value.
                startIndex = result.indexOf(this.placeholderPrefix, endIndex + this.placeholderSuffix.length());
            }
            else {
                throw new IllegalArgumentException("Could not resolve placeholder '" +
                        placeholder + "'" + " in value \"" + value + "\"");
            }
            visitedPlaceholders.remove(originalPlaceholder);
        }
        else {
            startIndex = -1;
        }
    }
    return result.toString();
}
```

## <span id="refresh">refresh() 解析</span>

refresh() 是初始化 ClassPathXmlApplicationContext 核心的方法，篇幅很长，先来一个代码概述：

```java
public void refresh() throws BeansException, IllegalStateException {
    // 为了避免 refresh() 还没结束，再次发起启动或者销毁容器引起冲突
    synchronized (this.startupShutdownMonitor) {
        // 1.refresh context 准备工作 **
        prepareRefresh();

        // 2.刷新、获取 BeanFactory
        // 负责 BeanFactory 的初始化、Bean 的加载和注册等事件 **
        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

        // 3.BeanFactory 使用前的准备工作
        // 设置 BeanFactory 的类加载器、添加 BeanPostProcessor、手动注册几个特殊的 bean **
        prepareBeanFactory(beanFactory);

        try {
            // 4.(扩展点) context 子类对 BeanFactory 的后置处理 
            postProcessBeanFactory(beanFactory);

            // 5.实例化并调用所有注册了 BeanFactoryPostProcessor 的 bean **
            invokeBeanFactoryPostProcessors(beanFactory);

            // 6.注册 BeanPostProcessor 的实现类，注意不是BeanFactoryPostProcessor
            // 此接口有两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization分别会在Bean初始化之前和初始化之后得到执行
            registerBeanPostProcessors(beanFactory);

            // 7.初始化 context 的 MessageSource(消息源的国际化) **
            initMessageSource();

            // 8.初始化 context 的事件广播器 **
            initApplicationEventMulticaster();

            // 9.(扩展点)在特定的 context 子类初始化特殊的 bean
            onRefresh();

            // 10.注册事件监听器 **
            registerListeners();

            // 11.实例化所有未实例化（非延迟初始化）的单例 bean **
            finishBeanFactoryInitialization(beanFactory);

            // 12.发布相应的事件 **
            finishRefresh();
        }

        catch (BeansException ex) {
            // 销毁已经初始化的的 bean
            destroyBeans();
            // 设置 'active' 状态
            cancelRefresh(ex);
            throw ex;
        }

        finally {
            // 清除缓存
            resetCommonCaches();
        }
    }
}

```

## 1.prepareRefresh() 解析

设置容器的启动时间，标记“已启动”状态，初始化、加载属性源，校验属性。

```java
protected void prepareRefresh() {
    // 设置容器的启动时间，标记“已启动”状态
    this.startupDate = System.currentTimeMillis();
    this.closed.set(false);
    this.active.set(true);

    // （扩展点）初始化 context 中所有带占位符的属性源
    initPropertySources();

    // 校验属性 **
    getEnvironment().validateRequiredProperties();

    // Store pre-refresh ApplicationListeners...
    if (this.earlyApplicationListeners == null) {
        this.earlyApplicationListeners = new LinkedHashSet<>(this.applicationListeners);
    }
    else {
        // Reset local application listeners to pre-refresh state.
        this.applicationListeners.clear();
        this.applicationListeners.addAll(this.earlyApplicationListeners);
    }

    // Allow for the collection of early ApplicationEvents,
    // to be published once the multicaster is available...
    this.earlyApplicationEvents = new LinkedHashSet<>();
}

public void validateRequiredProperties() throws MissingRequiredPropertiesException {
    this.propertyResolver.validateRequiredProperties();
}

public void validateRequiredProperties() {
    MissingRequiredPropertiesException ex = new MissingRequiredPropertiesException();
    for (String key : this.requiredProperties) {
        if (this.getProperty(key) == null) {
            // 1.为什么不直接抛出
            // throw new IllegalStateException("The following properties were declared as required but could not be resolved: "+key);
            ex.addMissingRequiredProperty(key);
        }
    }
    // 2.如果存在环境变量的value为空的时候就抛异常，停止启动Spring
    if (!ex.getMissingRequiredProperties().isEmpty()) {
        throw ex;
    }
}
```
思考一：为什么不直接抛出？ 

直接抛出 value 为 null 的 key，只能抛出一个(注释1)；注释2 中可以将所有环境变量值为 null 的 key 全部抛出；注释1 适用于请求时的参数校验、而注释2 适用于参数初始化。

思考二：基于参数校验机制的扩展

扩展 initPropertySources()，在 requiredProperties 集合中注入项目自定义的环境变量；例如：生产环境数据库地址、用户名和密码以环境变量的方式注入进去来代替测试环境的配置;我们可以在这里添加校验，从而在程序刚启动的时候就能发现问题。

[返回 refresh() 解析](#refresh)

## 2.obtainFreshBeanFactory() 解析
该方法负责 BeanFactory 的初始化、Bean 的加载和注册等事件。

```java
protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
    // ***
    refreshBeanFactory();
    // 返回 BeanFactory **
    return getBeanFactory();
}

protected final void refreshBeanFactory() throws BeansException {
    // 1.判断当前 context 是否存在 BeanFactory，若存在就销毁所有 Bean、关闭 BeanFactory（一个应用中可存在多个 BeanFactory，这儿判断的是当前 context）
    if (hasBeanFactory()) {
        destroyBeans();
        closeBeanFactory();
    }
    try {
        // 2.初始化 DefaultListableBeanFactory
        DefaultListableBeanFactory beanFactory = createBeanFactory();
        beanFactory.setSerializationId(getId());

        // 3.设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用
        customizeBeanFactory(beanFactory);

        // 4.加载 Bean 到 BeanFactory 中 **
        loadBeanDefinitions(beanFactory);
        synchronized (this.beanFactoryMonitor) {
            this.beanFactory = beanFactory;
        }
    }
    catch (IOException ex) {
        throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);
    }
}

```
DefaultListableBeanFactory 的继承关系图：

![DefaultListableBeanFactory](images/10.DefaultListableBeanFactory.png)


### loadBeanDefinitions() 解析
该方法会根据配置，加载各个 Bean，并放到 BeanFactory 中。

```java
protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {
    // 1.实例化 XmlBeanDefinitionReader
    // Create a new XmlBeanDefinitionReader for the given BeanFactory.
    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);

    // 2.初始化化 beanDefinitionReader
    // Configure the bean definition reader with this context's
    // resource loading environment.
    beanDefinitionReader.setEnvironment(this.getEnvironment());
    beanDefinitionReader.setResourceLoader(this);
    beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));
    // Allow a subclass to provide custom initialization of the reader,
    // then proceed with actually loading the bean definitions.
    initBeanDefinitionReader(beanDefinitionReader);

    // **
    loadBeanDefinitions(beanDefinitionReader);
}

protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {
    Resource[] configResources = getConfigResources();
    // 是否有系统指定的配置文件,若有先加载
    if (configResources != null) {
        reader.loadBeanDefinitions(configResources);
    }
    String[] configLocations = getConfigLocations();
    // 加载自定义配置文件 classpath:application-ioc.xml
    if (configLocations != null) {
        // **
        reader.loadBeanDefinitions(configLocations);
    }
}

public int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException {
    Assert.notNull(locations, "Location array must not be null");
    int count = 0;
    // 遍历并处理所有配置文件
    for (String location : locations) {
        // **
        count += loadBeanDefinitions(location);
    }
    // 返回所有加载的 BeanDefinition 的数量
    return count;
}

public int loadBeanDefinitions(String location) throws BeanDefinitionStoreException {
    // **
    return loadBeanDefinitions(location, null);
}

public int loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources) throws BeanDefinitionStoreException {
    ResourceLoader resourceLoader = getResourceLoader();
    if (resourceLoader == null) {
        throw new BeanDefinitionStoreException(
                "Cannot load bean definitions from location [" + location + "]: no ResourceLoader available");
    }
    if (resourceLoader instanceof ResourcePatternResolver) {
        // 可匹配资源模式
        try {
            // 将配置文件转换为 Resource 对象
            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);
            // **
            int count = loadBeanDefinitions(resources);
            if (actualResources != null) {
                Collections.addAll(actualResources, resources);
            }
            return count;
        }
        catch (IOException ex) {
            throw new BeanDefinitionStoreException(
                    "Could not resolve bean definition resource pattern [" + location + "]", ex);
        }
    }
    else {
        // 只能通过绝对路径加载单个资源
        Resource resource = resourceLoader.getResource(location);
        int count = loadBeanDefinitions(resource);
        if (actualResources != null) {
            actualResources.add(resource);
        }
        if (logger.isTraceEnabled()) {
            logger.trace("Loaded " + count + " bean definitions from location [" + location + "]");
        }
        return count;
    }
}

public int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException {
    Assert.notNull(resources, "Resource array must not be null");
    int count = 0;
    for (Resource resource : resources) {
        // **
        count += loadBeanDefinitions(resource);
    }
    return count;
}

public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {
    // **
    return loadBeanDefinitions(new EncodedResource(resource));
}

public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {
    Assert.notNull(encodedResource, "EncodedResource must not be null");

    Set<EncodedResource> currentResources = this.resourcesCurrentlyBeingLoaded.get();
    if (currentResources == null) {
        currentResources = new HashSet<>(4);
        this.resourcesCurrentlyBeingLoaded.set(currentResources);
    }
    // 用 ThreadLocal 缓存 resource，防止 resource 重复加载
    if (!currentResources.add(encodedResource)) {
        throw new BeanDefinitionStoreException(
                "Detected cyclic loading of " + encodedResource + " - check your import definitions!");
    }
    try {
        // 获取文件流
        InputStream inputStream = encodedResource.getResource().getInputStream();
        try {
            InputSource inputSource = new InputSource(inputStream);
            if (encodedResource.getEncoding() != null) {
                inputSource.setEncoding(encodedResource.getEncoding());
            }
            // 加载 **
            return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
        }
        finally {
            inputStream.close();
        }
    }
    catch (IOException ex) {
        throw new BeanDefinitionStoreException(
                "IOException parsing XML document from " + encodedResource.getResource(), ex);
    }
    finally {
        currentResources.remove(encodedResource);
        if (currentResources.isEmpty()) {
            this.resourcesCurrentlyBeingLoaded.remove();
        }
    }
}

protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
			throws BeanDefinitionStoreException {

    try {
        // 1.将 xml 文件流转换为 Document 对象
        Document doc = doLoadDocument(inputSource, resource);
        // 2.根据 Document 对象注册 Bean **
        return registerBeanDefinitions(doc, resource);
    }
    catch (Exception ex) {

    }
}

public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
    // 构建读取 Document 的工具类
    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
    // 获取已注册的 bean 数量
    int countBefore = getRegistry().getBeanDefinitionCount();
    // **
    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
    // 本次注册的 bean = 总注册的 bean - 之前注册的 bean
    return getRegistry().getBeanDefinitionCount() - countBefore;
}

public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {
    this.readerContext = readerContext;
    // 获取 Document 的根节点 **
    doRegisterBeanDefinitions(doc.getDocumentElement());
}

// 根据根节点注册每一个 BeanDefinition
protected void doRegisterBeanDefinitions(Element root) {
    // 当前根节点
    BeanDefinitionParserDelegate parent = this.delegate;
    this.delegate = createDelegate(getReaderContext(), root, parent);

    if (this.delegate.isDefaultNamespace(root)) {
        // 获取 <beans ... profile="***" /> 中的 profile 参数与当前环境是否匹配，如果不匹配则不再进行解析
        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
        if (StringUtils.hasText(profileSpec)) {
            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
            // 若不支持XML配置文件表达式，则不使用配置文件
            if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {
                if (logger.isDebugEnabled()) {
                    logger.debug("Skipped XML bean definition file due to specified profiles [" + profileSpec +
                            "] not matching: " + getReaderContext().getResource());
                }
                return;
            }
        }
    }
    // 前置扩展点
    preProcessXml(root);
    // **
    parseBeanDefinitions(root, this.delegate);
    // 后置扩展点
    postProcessXml(root);
    this.delegate = parent;
}

protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
    // default namespace 涉及到的就四个标签 <import />、<alias />、<bean /> 和 <beans />
    if (delegate.isDefaultNamespace(root)) {
        NodeList nl = root.getChildNodes();
        for (int i = 0; i < nl.getLength(); i++) {
            Node node = nl.item(i);
            if (node instanceof Element) {
                Element ele = (Element) node;
                if (delegate.isDefaultNamespace(ele)) {
                    // 解析 default namespace 下面的几个元素 **
                    parseDefaultElement(ele, delegate);
                }
                else {
                    // 解析其他 namespace 的元素
                    delegate.parseCustomElement(ele);
                }
            }
        }
    }
    else {
        // 解析其他 namespace 的元素
        delegate.parseCustomElement(root);
    }
}

private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
    // 处理 <import /> 标签
    if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
        importBeanDefinitionResource(ele);
    }
    // 处理 <alias /> 标签  <alias name="fromName" alias="toName"/>
    else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
        processAliasRegistration(ele);
    }
    // 处理 <bean /> 标签定义 **
    else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
        processBeanDefinition(ele, delegate);
    }
    // 处理 <beans /> 标签
    else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
        // recurse
        doRegisterBeanDefinitions(ele);
    }
}

// 以<bean /> 标签为例看 bean 是如何定义
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
    // 创建 BeanDefinition **
    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
    if (bdHolder != null) {
        // 如果有自定义属性则进行相应的解析
        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
        try {
            // 注册最终装饰实例 **
            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
        }
        catch (BeanDefinitionStoreException ex) {
            getReaderContext().error("Failed to register bean definition with name '" +
                    bdHolder.getBeanName() + "'", ele, ex);
        }
        // 发送注册事件
        getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
    }
}
```

#### parseBeanDefinitionElement() 解析
```java
public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {
    // **
    return parseBeanDefinitionElement(ele, null);
}

public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {
		String id = ele.getAttribute(ID_ATTRIBUTE);
		String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);

    // 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个别名列表数组，
    List<String> aliases = new ArrayList<>();
    if (StringUtils.hasLength(nameAttr)) {
        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
        aliases.addAll(Arrays.asList(nameArr));
    }

    // 如果没有指定 id, 那么用别名列表的第一个名字作为 beanName
    String beanName = id;
    if (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {
        beanName = aliases.remove(0);
    }

    if (containingBean == null) {
        checkNameUniqueness(beanName, aliases, ele);
    }
    // 根据 <bean ...>...</bean> 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中 **
    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
    // <bean /> 标签完成
    if (beanDefinition != null) {
        // 如果没有设置 id 和 name，那么此时的 beanName 就会为 null
        if (!StringUtils.hasText(beanName)) {
            try {
                if (containingBean != null) {
                    beanName = BeanDefinitionReaderUtils.generateBeanName(
                            beanDefinition, this.readerContext.getRegistry(), true);
                }
                else {
                    beanName = this.readerContext.generateBeanName(beanDefinition);
                    // 若生成器返回类名和后缀，则为 bean 注册别名
                    String beanClassName = beanDefinition.getBeanClassName();
                    if (beanClassName != null &&
                            beanName.startsWith(beanClassName) && beanName.length() > beanClassName.length() &&
                            !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
                        // 把 beanClassName 设置为 Bean 的别名
                        aliases.add(beanClassName);
                    }
                }
            }
            catch (Exception ex) {
                error(ex.getMessage(), ele);
                return null;
            }
        }
        String[] aliasesArray = StringUtils.toStringArray(aliases);
        // 返回 BeanDefinitionHolder
        return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
    }
    return null;
}

public AbstractBeanDefinition parseBeanDefinitionElement(
			Element ele, String beanName, @Nullable BeanDefinition containingBean) {

    this.parseState.push(new BeanEntry(beanName));
    String className = null;
    if (ele.hasAttribute(CLASS_ATTRIBUTE)) {
        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();
    }
    String parent = null;
    if (ele.hasAttribute(PARENT_ATTRIBUTE)) {
        parent = ele.getAttribute(PARENT_ATTRIBUTE);
    }
    try {
        // 创建 BeanDefinition 并设置类信息
        AbstractBeanDefinition bd = createBeanDefinition(className, parent);
        // 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中
        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));

        // 下面是解析 <bean>......</bean> 内部的子元素，解析出来以后的信息都放到 bd 的属性中
        // 解析 <meta />
        parseMetaElements(ele, bd);
        // 解析 <lookup-method />
        parseLookupOverrideSubElements(ele, bd.getMethodOverrides());
        // 解析 <replaced-method />
        parseReplacedMethodSubElements(ele, bd.getMethodOverrides());
        // 解析 <constructor-arg />
        parseConstructorArgElements(ele, bd);
        // 解析 <property />
        parsePropertyElements(ele, bd);
        // 解析 <qualifier />
        parseQualifierElements(ele, bd);

        bd.setResource(this.readerContext.getResource());
        bd.setSource(extractSource(ele));
        return bd;
    }
    catch (Exception ex) {
    }
    finally {
        this.parseState.pop();
    }
    return null;
}
```

#### registerBeanDefinition() 解析
```java
public static void registerBeanDefinition(
			BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
			throws BeanDefinitionStoreException {

    // 在主名称下注册 beanDefinition
    String beanName = definitionHolder.getBeanName();
    // **
    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

    // 如果配置有别名的话，也要根据别名全部注册一遍
    String[] aliases = definitionHolder.getAliases();
    if (aliases != null) {
        for (String alias : aliases) {
            registry.registerAlias(beanName, alias);
        }
    }
}

public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
			throws BeanDefinitionStoreException {

    Assert.hasText(beanName, "Bean name must not be empty");
    Assert.notNull(beanDefinition, "BeanDefinition must not be null");
    if (beanDefinition instanceof AbstractBeanDefinition) {
        try {
            ((AbstractBeanDefinition) beanDefinition).validate();
        }
        catch (BeanDefinitionValidationException ex) {
            throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                    "Validation of bean definition failed", ex);
        }
    }

    // 所有的 Bean 注册后都会被放入到这个 beanDefinitionMap 中，查看是否已存在这个 bean
    BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
    // 处理重复名称的 Bean 定义的情况
    if (existingDefinition != null) {
        if (!isAllowBeanDefinitionOverriding()) {
            // 若不允许覆盖则抛异常
            throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);
        }
        // 用框架定义的 Bean 覆盖用户自定义的 Bean
        else if (existingDefinition.getRole() < beanDefinition.getRole()) {
            if (logger.isInfoEnabled()) {
            }
        }
        // 用新的 Bean 覆盖旧的 Bean
        else if (!beanDefinition.equals(existingDefinition)) {
            if (logger.isDebugEnabled()) {
            }
        }
        // 用同等的 Bean 覆盖旧的 Bean
        else {
            if (logger.isTraceEnabled()) {
            }
        }
        // 覆盖
        this.beanDefinitionMap.put(beanName, beanDefinition);
    }
    else {
        // 判断是否已经有其他的 Bean 开始初始化了.
        // 注意:"注册Bean" 这个动作结束，Bean 依然还没有初始化 在 Spring 容器启动的最后，会预初始化所有的 singleton beans
        if (hasBeanCreationStarted()) {
            // Cannot modify startup-time collection elements anymore (for stable iteration)
            synchronized (this.beanDefinitionMap) {
                this.beanDefinitionMap.put(beanName, beanDefinition);
                List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
                updatedDefinitions.addAll(this.beanDefinitionNames);
                updatedDefinitions.add(beanName);
                this.beanDefinitionNames = updatedDefinitions;
                removeManualSingletonName(beanName);
            }
        }
        else {
            // 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition
            // Still in startup registration phase
            this.beanDefinitionMap.put(beanName, beanDefinition);
            // ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字
            this.beanDefinitionNames.add(beanName);
            // LinkedHashSet，代表的是手动注册的 singleton bean，
            removeManualSingletonName(beanName);
        }
        this.frozenBeanDefinitionNames = null;
    }

    if (existingDefinition != null || containsSingleton(beanName)) {
        resetBeanDefinition(beanName);
    }
}
```










